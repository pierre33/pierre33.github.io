---
layout: tuto_algos
---
<h2 class="main-title">Intersection of two linked lists</h2>

<h3 id="cmake" class="second-title">Problem statement</h3>
<p>
We consider a linked list where each node has the following data structure:
<pre class="prettyprint">
	<code class="cc">
	struct ListNode
	{
		int val;
		ListNode *next;
		ListNode(int x) : val(x), next(NULL){}
	};
	</code>
</pre>
We consider two linked lists L1 and L2. The goal is to determine if there is an intersection
between L1 and L2. The following figure represents an example of intersection of two 
linked lists.
</p>
<img  style="display:block; margin:0 auto; height:250px;"
			src="img_algos/linkedLists1.png"/>
<p>
Indeed, in this figure, both lists share the same nodes from c1 to c3.
<br/>
Given the following prototype of the function:
<pre class="prettyprint">
	<code class="cc">
	ListNode* getIntersectionNode(ListNode *headA, ListNode *headB)
	</code>
</pre>
the objective is to propose an algorithm with a time complexity of O(n) and a memory
complexity of O(1).
<br/>
If there is no intersection between both lists, the function must return NULL.
<br />
Finally we assume that there are no cycles in both lists.
<br/>
Before delving into the reasonning, I invite you to try to solve this solution and to come back after while ;)
</p>
<h3 id="cmake" class="second-title">First reasonning</h3>
<p>
Let see the first solution that comes into mind without taking care about the requirements.
An easy solution would be for each node of a list to explore all the nodes of the other list
and test if they are equal:
<pre class="prettyprint">
	<code class="cc">
	  ListNode* getIntersectionNode(ListNode *headA, ListNode *headB)
	  {
	      if(headA == NULL || headB == NULL)
	          return NULL;

	      for(ListNode * tempA = headA; tempA != NULL; tempA = tempA->next)
	      {
	          for(ListNode * tempB = headB; tempB != NULL; tempB = tempB->next)
              {
	              if(tempA == tempB)
                     return tempA;
              }
	      }
          return NULL;
	  }
	</code>
</pre>
This solution is O(1) memory complexity but the time complexity in the worst and average case is O(n*m) if n is the
size of the first list and m the size of the second list. The proposed solution does not fit the requirement so we will
need to optimize it.
</p>
<h3 id="cmake" class="second-title">Second reasonning</h3>
<p>
I repeat here what is important is not to code the solution but how we find the solution.
The requirement is that the time complexity has to be in linear time and the memory complexity has to be constant.
<br/>
So the solution is more or less similar to an algorithm that finds the intersection in one scan of the nodes of one
of the list.
<br/> 
The first idea that comes into mind is to start with two pointers targeting the first nodes of both lists and
then comparing side-by-side the nodes scanning in parallel both lists. You will tell me that is not so clever
because if the lists have different size (and it is the general case) it will not work. I completely agree but
guess what it is the starting point of the good solution !
<br/>
Indeed, if I find the starting nodes for both lists where I am sure that the number of the remaining nodes to scan
is the same then I can do the solution I just described before. The following figure will help you to understand.
<img  style="display:block; margin:0 auto; height:300px;"
			src="img_algos/linkedLists2.png"/>
</p>
