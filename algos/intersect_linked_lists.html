---
layout: tuto_algos
---
<h2 class="main-title">Intersection of two linked lists</h2>

<h3 id="cmake" class="second-title">Problem statement</h3>
<p>
We consider a linked list where each node has the following data structure:
<pre class="prettyprint">
	<code class="cc">
	struct ListNode
	{
		int val;
		ListNode *next;
		ListNode(int x) : val(x), next(NULL){}
	};
	</code>
</pre>
We consider two linked lists L1 and L2. The goal is to determine if there is an intersection
between L1 and L2. The following figure represents an example of intersection of two 
linked lists.
</p>
<img  style="display:block; margin:0 auto; height:250px;"
			src="img_algos/linkedLists1.png"/>
<p>
Indeed, in this figure, both lists share the same nodes from c1 to c3.
<br/>
Given the following prototype of the function:
<pre class="prettyprint">
	<code class="cc">
	ListNode* getIntersectionNode(ListNode *headA, ListNode *headB)
	</code>
</pre>
the objective is to propose an algorithm with a time complexity of O(n) and a memory
complexity of O(1).
<br/>
If there is no intersection between both lists, the function must return NULL.
<br />
Finally we assume that there are no cycles in both lists.
<br/>
Before delving into the reasonning, I invite you to try to solve this solution and to come back after while ;)
</p>
<h3 id="cmake" class="second-title">First reasonning</h3>
<p>
Let see the first solution that comes into mind without taking care about the requirements.
An easy solution would be for each node of a list to explore all the nodes of the other list
and test if they are equal:
<pre class="prettyprint">
	<code class="cc">
	  ListNode* getIntersectionNode(ListNode *headA, ListNode *headB)
	  {
	      if(headA == NULL || headB == NULL)
	          return NULL;

	      for(ListNode * tempA = headA; tempA != NULL; tempA = tempA->next)
	      {
	          for(ListNode * tempB = headB; tempB != NULL; tempB = tempB->next)
              {
	              if(tempA == tempB)
                     return tempA;
              }
	      }
          return NULL;
	  }
	</code>
</pre>
This solution is O(1) memory complexity but the time complexity in the worst and average case is O(n*m) if n is the
size of the first list and m the size of the second list. The proposed solution does not fit the requirement so we will
need to optimize it.
</p>
<h3 id="cmake" class="second-title">Second reasonning</h3>
<p>
I repeat here what is important is not to code the solution but how we find the solution.
The requirement is that the time complexity has to be in linear time and the memory complexity has to be constant.
<br/>
So the solution is more or less similar to an algorithm that finds the intersection in one scan of the nodes of one
of the list.
<br/> 
The first idea that comes into mind is to start with two pointers targeting the first nodes of both lists and
then comparing side-by-side the nodes scanning in parallel both lists. You will tell me that is not so clever
because if the lists have different size (and it is the general case) it will not work. I completely agree but
it is the starting point of the good solution !
<br/>
Indeed, if I find the starting nodes for both lists where I am sure that the number of the remaining nodes to scan
is the same then I can do the solution I just described before. The following figure will help you to understand.
<img  style="display:block; margin:0 auto; height:300px;"
			src="img_algos/linkedLists2.png"/>
If we start with a2 from L1 and b1 from L2 then we just have to scan the remaining nodes of both lists in parallel until
both nodes are equal. For example in the figure above, we will first compare a2 and b1, a3 and b2 and c3 and c3. We stop and we return
c3.
<br/>
How to determine the starting nodes ?<br/>
I think by looking at the figure, you guess how to do it right ? Indeed if we know the size of both lists and then compare
these sizes we know where to start.
<br/>
<ul>
  <li>If m = n, the starting nodes are simply the first nodes of both lists.</li>
  <li>If n > m then the starting nodes are the (n-m)<sup>th</sup> of the first list and the first node of the second list.
  <li>If m > n then the starting nodes are the (m-n)<sup>th</sup> of the second list and the first node of the first list.
</ul>
It is time to analyse the time complexity of our solution in the worst case. Determining the size of both lists is achieved in linear time
by simply scanning all the nodes of each list. Going to the starting nodes is achieved in linear time in the worst case (if we have to go to the last node of one list). Finally, comparing the nodes is achieved also in linear time. It seems that this solution fulfills the requirements :).
<br/>
Here is the source code of the solution:
<pre class="prettyprint">
	<code class="cc">
	  ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA == NULL || headB == NULL)
            return NULL;
        
        int countA = 0, countB = 0;
        ListNode * tempA = headA;
        ListNode * tempB = headB;
        
        for(; tempA != NULL; tempA = tempA->next)
            countA++;
        for(; tempB != NULL; tempB = tempB->next)
            countB++;
            
        tempA = headA;
        tempB = headB;
        
        if(countA != countB)
        {
            if(countA > countB)
            {
                for(int i=0; i<countA-countB; ++i)
                    tempA = tempA->next;
            }
            else
            {
                for(int i=0; i<countB-countA; ++i)
                    tempB = tempB->next;
            }
        }
        
        while(tempA != NULL && tempB !=NULL)
        {
		  if(tempA == tempB)
		    return tempA;

            tempA = tempA->next;
            tempB = tempB->next;
        }
        return NULL;
    }
	</code>
</pre>
</p>
