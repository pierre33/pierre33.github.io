---
layout: tuto_layout
---

<h2 class="main-title"> GRM Library Tutorial: User Guide</h2>
<ol>
	<li><a href="#rm">Region Merging: generic description</a></li>
	<ol type="i">
		<li><a href="#heu">Heuristic used</a></li>
		<li><a href="#params">Common parameters</a></li>
	</ol>
	<li><a href="#criter">Baatz & Sch채pe criterion</a></li>
</ol>


<h3 id="rm" class="second-title"> Region Merging </h3>
<p class="explanation">
Region merging algorithms have proven to be an effective approach for image segmentation, especially for OBIA (Object-Based Image Analysis) in remote sensing. The basic approach of a region merging algorithm is to consider at the beginning every pixel of the image as an initial region. These regions are then merged iteratively to form the objects of the image. Region merging algorithms vary depending on the criteria used to decide whether two adjacent regions have to be merged and the heuristic to find for a region, its adjacent region to be merged.
<!---------------------------------------------------------------------------------->
<h4 id="heu" class="third-title">Heuristic used</h4>
At each iteration, we want to determine which regions have to be merged. 
<br/>Different heuristics are proposed in the litterature:
<ul>
	<li><i>Fitting (F)</i>: A region R1 is merged randomly with one of its adjacent region 
		R2 for which the homogeneity criterion is fulfilled.
	</li>
	<li>
		<i>Best Fitting (BF)</i>: For a region R1, we retain one of its adjacent region
		R2 for which the homogeneity criterion is fulfilled the best.
	</li>
	<li>
		<i>Local Mutual Best Fitting (LMBF)</i>: For a region R1, we determine its most similar
		adjacent region R2. For R2, we determine its most similar adjacent region R3.
		R1 and R2 are merged if R3 = R1.
	</li>
	<li>
		<i>Global Mutual Best Fitting (GMBF)</i>: At each iteration, we merge the pair of adjacent
		regions in the whole image which fulfills the homogeneity criterion the best.
	</li>
</ul>
The <i>LMBF</i> and <i>BF</i> heuristics have been selected in the GRM library. The
<i>LMBF</i> heuristic allows a symmetric growth of the regions while minimizing the
global heterogeneity within the final regions of the image. This heuristic shows
high quality segmentation results compared to the others.
However this heuristic requires more iterations since the constraints to merge regions are stronger. 
That is why it is possible for the user to have speedup by combining the <i>BF</i> heuristic with the 
<i>LMBF</i> heuristic or even by using only the <i>BF</i> heuristic. Be careful that in
this case the quality of the results would be lower.
</p>
<!---------------------------------------------------------------------------------->
<h4 id="params" class="third-title">Common parameters</h4>
<p>
This section describes the common parameters of a region merging algorithm
that have to be specified by the user when using an algorithm from the GRM library.
</p>
<p>
First, the user has to indicate the path to the image to segment. The following format
are accepted with the otb library: (.jpg, .png, .tif). The method <i>SetInputFileName(filename)</i>
of the generic class <i>RegionMergingAlgorithm</i> has to be called:
<pre class="prettyprint">
	<code class="cc">
	segmenter.SetInputFileName(inputFileName);
	</code>
</pre>
The proposed outputs of the GRM library are a label ouput image, a clustered output rgb image 
and a contour output image.
<br/>
Both outputs require a path to write the corresponding image:
<pre class="prettyprint">
	<code class="cc">
	segmenter.SetClusteredImageFileName(clustered_image); // clustered image
	segmenter.SetLabelImageFileName(label_image); // label image
	</code>
</pre>
Specific parameters to the region merging algorithm are needed:
<pre class="prettyprint">
	<code class="cc">
	segmenter.SetParam(params);
	</code>
</pre>
The declaration and initialization of the variable <i>params</i> is specific to a criterion
and will be described later.  
</p>
<p>
As mentioned previously, two heuristics are proposed in the GRM library: <i>LMBF</i>
and <i>BF</i>.
By default, the merging process is using a combination of both heuristics. The first
75 iterations are done with the <i>LMBF</i> heuristic and then, if there are still regions to
be merged, we switch with the <i>BF</i> heuristic and achieve the segmentation until there are no merges
anymore.
<br/>
The user has the possibility to change this configuration by tuning the number of iterations
 when using the <i>LMBF</i> heuristic and by activating or desactivating the use of the
<i>BF</i> heuristic.
<pre class="prettyprint">
	<code class="cc">
	segmenter.SetNumberOfIterations(30);
	segmenter.SetDoBestFitting(true);
	</code>
</pre>
In this example, we choose to process the 30 first iterations using the <i>LMBF</i>
and then we switch with the <i>BF</i> heuristic to achieve the segmentation.
<br/>
The following example shows that it is possible to impose a fix number of iterations
using the <i>LMBF</i> heuristic without activating the <i>BF</i> heuristic.
<pre class="prettyprint">
	<code class="cc">
	segmenter.SetNumberOfIterations(40);
	segmenter.SetDoBestFitting(false);
	</code>
</pre>
It is possible to use only the <i>LMBF</i> heuristic to process the segmentation by
passing an "infinite" number of iterations:
<pre class="prettyprint">
	<code class="cc">
	unsigned int max_iter = std::numeric_limits&lt;unsigned int&gt;max();
	segmenter.SetNumberOfIterations(max_iter);
	</code>
</pre>
Or to use only the <i>BF</i> heuristic:
<pre class="prettyprint">
	<code class="cc">
	segmenter.SetNumberOfIterations(0);
	segmenter.SetDoBestFitting(true);
	</code>
</pre>
</p>
<h4 id="bs" class="third-title"> Baatz & Sch채pe criterion </h3>
<p>
This criterion is based on spectral and shape information. The spectral information
is the standard deviation of the spectral intensities of the pixels within the regions
and the shape information is based on the degree of smoothness and compactness of the
region shapes. <br/>
Two weight parameters allow to configure the relative importance of the spectral and
shape information. Their values range from 0 to 1.
<br/>
Finally, in order to limit the under-segmentation, the user has to choose a value for
the scale parameter which influences the size of the resulting regions. Its value has
to be positive and depends on the nature of the objects to be extracted. A small value
leads to small objects and a large value leads to larger objects. 
</p>
<p>
This criterion was first introduced in this 
<a href="http://scholar.google.fr/scholar?hl=fr&q=Multiresolution+Segmentation%3A+an+optimization+approach+for+high+quality+multi-scale+image+segmentation&btnG=&lr=">
publication</a>.
</p>
<p>
The source code for this example can be found in the file:<br/>
<i>grm/src/Applications/RegionMergingSegmentation.cxx</i>
</p>
<p>
Let's look at the minimal code required to use this algorithm. First the following header
defining the Baatz algorithm class must be included:
<pre class="prettyprint">
	<code class="cc">
	#include "lsrmBaatzSegmenter.h"
	</code>
</pre>
Then, the headers to handle an otb vector image have to included:
<pre class="prettyprint">
	<code class="cc">
	#include &lt;otbImageFileReader.h&gt;
	#include &lt;otbVectorImage.h&gt;
	</code>
</pre>
We declare the image type based on a particular pixel type and dimension. In this case the
<i>float</i> type is used and the dimension of the image is obviously 2.
<pre class="prettyprint">
	<code class="cc">
	typedef float PixelType;
	typedef otb::VectorImage&lt;PixelType, 2&gt; ImageType;
	</code>
</pre> 
Next, we declare the Baatz & Sch채pe region merging algorithm based on the image type
we have just declared.
<pre class="prettyprint">
	<code class="cc">
	typedef lsrm::BaatzSegmenter&lt;ImageType&gt; SegmenterType;
	</code>
</pre> 
We declare and construct the parameters specific to the Baatz & Sch채pe criterion, i.e.,
the spectral weight, the shape weight and the scale parameter.
<pre class="prettyprint">
	<code class="cc">
	BaatzParams params = {0.5, 0.5, 40};
	</code>
</pre> 
Then we construct our segmenter.
<pre class="prettyprint">
	<code class="cc">
	SegmenterType segmenter;
	</code>
</pre>
We pass the common parameters described previously.
<pre class="prettyprint">
	<code class="cc">
	segmenter.SetParam(params);
	segmenter.SetThreshold(scale);
	segmenter.SetInputFileName(input_image);
	segmenter.SetClusteredImageFileName(clustered_image);
	segmenter.SetLabelImageFileName(label_image);
	</code>
</pre>
And finally we run the segmentation process.
<pre class="prettyprint">
	<code class="cc">
	segmenter.RunSegmentation();
	</code>
</pre>
<p>
Using the test image provided with the grm library in the directory <i>img/</i>, 
we obtain the resulting clustered image with a scale value of 40, a spectral weight of 0.5 and a shape weight of 0.5.
</p>
<img  style="display:block; margin:0 auto; height:500px; width:500pSx;"
			src="img_tuto/refsegment.jpg"/>
<img  style="display:block; margin:0 auto; height:500px; width:500pSx;"
			src="img_tuto/refbaatzoutput.jpg"/>
